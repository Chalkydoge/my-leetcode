# 编辑距离II

> 72题的简化版本(不能插入字符)

给你两个单词 s 和 t，请你计算出将 s 转换成 t 所使用的最少操作数。

你可以对一个单词进行如下两种操作：
>删除一个字符
>替换一个字符

注意：
>不允许插入操作
>题目保证有解

示例：

输入：s = "abcdefg", t = "abdde"
输出：3

提示：
1 <= len(s), len(t) <= 200

## Code

详解请见注释:

- 对付字符串的公共子串问题, 动态规划往往是应对问题的最优解;

- 按照暴力的想法, 自然是对于每一个字符作删除/更改的考虑, 枚举更改当前字符的最小操作数+删除当前字符后的最小操作数, 遍历整个字符串并最终求解;

- 但是这样的算法忽略了许多信息, 导致时间复杂度过高,因此我们需要通过其他的方法进行优化;

- 注意到删除字符的操作实际上不会对更改字符结果产生影响,因此我们可以先考虑字符串的更改次数,再求取字符串所有位置的最小更改次数, 最终再加上长度上不匹配的部分, 就获得了最终的答案.

> 例如: S = "AAA", T = "AB"
> 对于第二个A, 我们先删除掉, 再更改第三个A为B 或者是 先修改为B, 再删除第三个A, 都是完全一致的(删除的位置不会影响最终答案的大小)

```cpp
class Solution {
public:
    int dp[205][205];

    int edit_distance(string s, string t) {
        int m = s.size(), n = t.size();
        memset(dp, 0, sizeof(dp));
        // 这里只先考虑替换的次数, 因为删除操作不会影响替换的结果
        // t[i] == s[j], dp[i][j] = dp[i - 1][j - 1]
        // t[i] != s[j], dp[i][j] = dp[i][j - 1], dp[i - 1][j - 1] + 1
        dp[0][0] = 0;
        // dp[0][1] = t[0:0] ^ s[0:1] = 0(no need to change char)
        // dp[1][0] = t[0:1] ^ s[0:0]
        for(int i = 1; i <= n; ++i){
            dp[i][i] = dp[i - 1][i - 1] + !(t[i - 1] == s[i - 1]);
        }

        for(int i = 1; i <= n; ++i){
            for(int j = i + 1; j <= m; ++j){
                if(t[i - 1] == s[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else{
                    dp[i][j] = min(dp[i - 1][j - 1] + 1, dp[i][j - 1]);
                }
            }
        }

        return dp[n][m] + (m - n);
    }
};
```
